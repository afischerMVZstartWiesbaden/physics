<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Todo Bälle</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=Syne+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #111118;
    overflow: hidden;
    font-family: 'Syne', sans-serif;
    height: 100vh; width: 100vw;
  }

  /* Canvas stays BELOW all UI */
  #c {
    display: block;
    position: fixed;
    top: 0; left: 0;
    z-index: 1;
  }

  /* All UI sits on top */
  #ui {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 20;
  }

  /* Header */
  #header {
    position: fixed;
    top: 28px; left: 36px;
    z-index: 21;
  }
  #header .label {
    font-family: 'Syne Mono', monospace;
    font-size: 9px; letter-spacing: 0.28em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.2);
    margin-bottom: 5px;
  }
  #header h1 {
    font-size: 22px; font-weight: 800;
    color: rgba(255,255,255,0.8);
    letter-spacing: -0.02em;
  }

  /* Filter tabs */
  #filter-tabs {
    position: fixed;
    top: 72px; left: 36px;
    display: flex; gap: 4px;
    z-index: 21;
    pointer-events: all;
    background: rgba(10,10,18,0.7);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 3px;
    padding: 4px;
  }
  .ftab {
    font-family: 'Syne Mono', monospace;
    font-size: 10px; letter-spacing: 0.12em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.3);
    background: transparent;
    border: none;
    padding: 6px 14px;
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.2s;
    display: flex; align-items: center; gap: 6px;
  }
  .ftab:hover { color: rgba(255,255,255,0.65); }
  .ftab.active {
    color: #fff;
    background: rgba(255,255,255,0.1);
  }
  .ftab-dot {
    width: 7px; height: 7px;
    border-radius: 50%;
  }

  /* Done panel */
  #done-panel {
    position: fixed;
    top: 80px; right: 36px;
    width: 230px;
    background: rgba(10,10,16,0.82);
    backdrop-filter: blur(14px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 3px;
    padding: 14px 16px;
    max-height: 55vh;
    overflow-y: auto;
    display: none;
    z-index: 21;
  }
  #done-panel::-webkit-scrollbar { width: 3px; }
  #done-panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); }
  .done-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 10px; padding-bottom: 8px;
    border-bottom: 1px solid rgba(255,255,255,0.07);
  }
  .done-label {
    font-family: 'Syne Mono', monospace; font-size: 9px;
    letter-spacing: 0.25em; text-transform: uppercase;
    color: rgba(255,255,255,0.25);
  }
  .done-count {
    font-family: 'Syne Mono', monospace; font-size: 11px;
    color: rgba(255,255,255,0.35);
    background: rgba(255,255,255,0.07);
    padding: 2px 7px; border-radius: 10px;
  }
  #done-list { list-style: none; }
  #done-list li {
    display: flex; align-items: center; gap: 8px;
    font-size: 12px; color: rgba(255,255,255,0.38);
    font-family: 'Syne', sans-serif;
    padding: 5px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    text-decoration: line-through;
    text-decoration-color: rgba(255,255,255,0.15);
  }
  #done-list li:last-child { border: none; }
  .done-pip { width: 5px; height: 5px; border-radius: 50%; flex-shrink: 0; opacity: 0.5; }
  .done-time {
    font-family: 'Syne Mono', monospace; font-size: 9px;
    color: rgba(255,255,255,0.18); margin-left: auto; white-space: nowrap;
  }

  /* Add bar — solid background so balls don't show through */
  #add-bar {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 80px;
    background: #111118;
    border-top: 1px solid rgba(255,255,255,0.07);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    z-index: 22;
    pointer-events: all;
  }
  #add-input {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.15);
    color: #fff;
    font-family: 'Syne', sans-serif; font-size: 13px;
    padding: 10px 18px; border-radius: 2px;
    outline: none; width: 280px;
    transition: border-color 0.2s;
  }
  #add-input::placeholder { color: rgba(255,255,255,0.2); }
  #add-input:focus { border-color: rgba(255,255,255,0.35); }
  #prio-select {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.6);
    font-family: 'Syne Mono', monospace; font-size: 11px;
    padding: 10px 14px; border-radius: 2px;
    outline: none; cursor: pointer;
  }
  #add-btn {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    font-family: 'Syne', sans-serif; font-size: 12px;
    font-weight: 700; letter-spacing: 0.1em;
    padding: 10px 20px; cursor: pointer; border-radius: 2px;
    transition: all 0.2s;
  }
  #add-btn:hover { background: rgba(255,255,255,0.18); color: #fff; }

  /* Hint */
  #hint {
    position: fixed;
    bottom: 88px; left: 50%;
    transform: translateX(-50%);
    font-family: 'Syne Mono', monospace; font-size: 9px;
    letter-spacing: 0.2em; text-transform: uppercase;
    color: rgba(255,255,255,0.1);
    white-space: nowrap;
    z-index: 21; pointer-events: none;
  }

  /* Swipe arrows */
  #swipe-left, #swipe-right {
    position: fixed; top: 50%;
    transform: translateY(-50%);
    font-size: 32px;
    color: rgba(255,255,255,0.04);
    pointer-events: none;
    transition: all 0.2s;
    z-index: 5;
  }
  #swipe-left { left: 16px; }
  #swipe-right { right: 16px; }
  .swipe-active { color: rgba(100,220,120,0.55) !important; }

  /* Tooltip */
  #tooltip {
    position: fixed;
    background: rgba(10,10,18,0.95);
    border: 1px solid rgba(255,255,255,0.12);
    padding: 8px 12px; border-radius: 3px;
    font-size: 11px; color: rgba(255,255,255,0.7);
    pointer-events: none; opacity: 0;
    transition: opacity 0.15s;
    font-family: 'Syne Mono', monospace;
    max-width: 200px; z-index: 30;
  }
  #tooltip.show { opacity: 1; }
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="swipe-left">✓</div>
<div id="swipe-right">✓</div>

<div id="ui">
  <div id="header">
    <div class="label">Aktuelle Todos</div>
    <h1>Todo Bälle</h1>
  </div>

  <div id="filter-tabs">
    <button class="ftab active" data-filter="all" onclick="setFilter('all')">Alle</button>
    <button class="ftab" data-filter="urgent" onclick="setFilter('urgent')">
      <span class="ftab-dot" style="background:#E07070"></span>Dringend
    </button>
    <button class="ftab" data-filter="workflow" onclick="setFilter('workflow')">
      <span class="ftab-dot" style="background:#7090C8"></span>Workflow
    </button>
    <button class="ftab" data-filter="reminder" onclick="setFilter('reminder')">
      <span class="ftab-dot" style="background:#70B890"></span>Erinnerung
    </button>
  </div>

  <div id="done-panel">
    <div class="done-header">
      <span class="done-label">Erledigt</span>
      <span class="done-count" id="done-count">0</span>
    </div>
    <ul id="done-list"></ul>
  </div>

  <div id="hint">Ziehen · Klick+Scroll = Größe · Links/Rechts raus = Erledigt · Doppelklick = Löschen</div>
</div>

<div id="add-bar">
  <input id="add-input" type="text" placeholder="Neues Todo …" />
  <select id="prio-select">
    <option value="urgent">Dringend</option>
    <option value="workflow" selected>Workflow</option>
    <option value="reminder">Erinnerung</option>
  </select>
  <button id="add-btn" onclick="addTodo()">+ Hinzufügen</button>
</div>

<div id="tooltip"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, Body, Composite, Events, Mouse, MouseConstraint } = Matter;

const COLORS = {
  urgent:   { fill: '#E07070', glow: '#E07070' },
  workflow: { fill: '#7090C8', glow: '#7090C8' },
  reminder: { fill: '#70B890', glow: '#70B890' },
};
const SIZES = { urgent: 60, workflow: 48, reminder: 36 };

const INITIAL_TODOS = [
  { text: 'Kaffeemaschine\nentkalken',  type: 'reminder' },
  { text: 'IVP Makro\ntesten',          type: 'workflow'  },
  { text: 'PsychoEQ\nServer testen',    type: 'workflow'  },
  { text: 'Stundenabgleich\nMärz',      type: 'urgent'    },
  { text: 'WireGuard\ndokumentieren',   type: 'reminder'  },
  { text: 'Netzwerkplan\nfinalisieren', type: 'workflow'  },
  { text: 'Protokoll\nTeammeeting',     type: 'urgent'    },
  { text: 'BTT Shortcuts\naufräumen',   type: 'reminder'  },
];

let W = window.innerWidth;
let H = window.innerHeight - 80; // leave room for add bar
let nextId = 100;
let activeFilter = 'all';

const canvas = document.getElementById('c');
canvas.width = W; canvas.height = H;
const ctx = canvas.getContext('2d');

// Matter engine
const engine = Engine.create({ gravity: { x: 0, y: 0.22 } });
const world = engine.world;

function buildWalls() {
  return [
    Bodies.rectangle(W/2, H + 30, W + 200, 60, { isStatic: true, label: 'wall' }),
    Bodies.rectangle(-30,  H/2, 60, H*3,        { isStatic: true, label: 'wall' }),
    Bodies.rectangle(W+30, H/2, 60, H*3,        { isStatic: true, label: 'wall' }),
    Bodies.rectangle(W/2, -30, W + 200, 60,     { isStatic: true, label: 'wall' }),
  ];
}
let walls = buildWalls();
Composite.add(world, walls);

// Mouse constraint (only active when not in swipe mode)
const mouse = Mouse.create(canvas);
mouse.element.removeEventListener('mousewheel', mouse.mousewheel);
mouse.element.removeEventListener('DOMMouseScroll', mouse.mousewheel);
const mc = MouseConstraint.create(engine, {
  mouse,
  constraint: { stiffness: 0.07, damping: 0.08, render: { visible: false } }
});
Composite.add(world, mc);

// ─── BALL STATE ────────────────────────────────────────────────────────────
let balls = [];       // { body, data, r, id, visible }
let doneTodos = [];

function spawnBall(todo) {
  const r = SIZES[todo.type] || 44;
  const x = W * 0.25 + Math.random() * W * 0.5;
  const y = 80 + Math.random() * (H * 0.5);
  const body = Bodies.circle(x, y, r, {
    restitution: 0.52, friction: 0.015, frictionAir: 0.016, density: 0.003, label: 'ball',
  });
  Body.setVelocity(body, { x: (Math.random()-0.5)*4, y: (Math.random()-0.5)*3 });
  const id = todo.id || nextId++;
  const ballObj = { body, data: { ...todo, id }, r, id, visible: true, inWorld: true };
  Composite.add(world, body);
  balls.push(ballObj);
  applyFilter(); // respect current filter
}

function addTodo() {
  const input = document.getElementById('add-input');
  const type = document.getElementById('prio-select').value;
  const text = input.value.trim();
  if (!text) return;
  const words = text.split(' ');
  const half = Math.ceil(words.length / 2);
  const displayText = words.length > 1
    ? words.slice(0, half).join(' ') + '\n' + words.slice(half).join(' ')
    : text;
  spawnBall({ text: displayText, type, id: nextId++ });
  input.value = '';
  input.focus();
}

document.getElementById('add-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') addTodo();
});

// ─── FILTER ────────────────────────────────────────────────────────────────
function setFilter(f) {
  activeFilter = f;
  document.querySelectorAll('.ftab').forEach(b => b.classList.toggle('active', b.dataset.filter === f));
  applyFilter();
}

function applyFilter() {
  balls.forEach(ball => {
    const show = activeFilter === 'all' || ball.data.type === activeFilter;
    const wasVisible = ball.visible;
    ball.visible = show;

    if (!show && wasVisible) {
      // Remove from physics world entirely
      Composite.remove(world, ball.body);
      ball.inWorld = false;
    } else if (show && !wasVisible) {
      // Re-add to physics world at a fresh position
      const x = W * 0.25 + Math.random() * W * 0.5;
      const y = 100 + Math.random() * (H * 0.35);
      const newBody = Bodies.circle(x, y, ball.r, {
        restitution: 0.52, friction: 0.015, frictionAir: 0.016, density: 0.003, label: 'ball',
      });
      Body.setVelocity(newBody, { x: (Math.random()-0.5)*4, y: (Math.random()-0.5)*3 });
      ball.body = newBody;
      Composite.add(world, newBody);
      ball.inWorld = true;
    }
  });
}

// ─── SWIPE TO DONE ─────────────────────────────────────────────────────────
let swipeState = null; // { ballIdx, startX, startY, bodyStartX }

canvas.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  const mx = e.clientX, my = e.clientY;
  for (let i = 0; i < balls.length; i++) {
    const b = balls[i];
    if (!b.visible) continue;
    const dx = mx - b.body.position.x;
    const dy = my - b.body.position.y;
    if (Math.sqrt(dx*dx + dy*dy) < b.r) {
      swipeState = { ballIdx: i, startX: mx, startY: my, bodyStartX: b.body.position.x };
      break;
    }
  }
});

window.addEventListener('mousemove', e => {
  if (!swipeState) return;
  const dx = e.clientX - swipeState.startX;
  const threshold = 60;
  document.getElementById('swipe-left').classList.toggle('swipe-active', dx < -threshold);
  document.getElementById('swipe-right').classList.toggle('swipe-active', dx > threshold);
});

window.addEventListener('mouseup', e => {
  if (swipeState) {
    const dx = e.clientX - swipeState.startX;
    if (Math.abs(dx) > 80) {
      // Mark done regardless of where the ball physically is
      markDone(swipeState.ballIdx);
    }
    swipeState = null;
    document.getElementById('swipe-left').classList.remove('swipe-active');
    document.getElementById('swipe-right').classList.remove('swipe-active');
  }
});

function markDone(idx) {
  if (idx < 0 || idx >= balls.length) return;
  const ball = balls[idx];
  const now = new Date();
  const timeStr = now.getHours() + ':' + String(now.getMinutes()).padStart(2,'0');
  doneTodos.unshift({ ...ball.data, time: timeStr });
  Composite.remove(world, ball.body);
  balls.splice(idx, 1);
  if (selectedIdx === idx) selectedIdx = -1;
  else if (selectedIdx > idx) selectedIdx--;
  if (swipeState && swipeState.ballIdx === idx) swipeState = null;
  renderDoneList();
  updateCount();
}

function renderDoneList() {
  const panel = document.getElementById('done-panel');
  const list = document.getElementById('done-list');
  document.getElementById('done-count').textContent = doneTodos.length;
  panel.style.display = doneTodos.length > 0 ? 'block' : 'none';
  list.innerHTML = doneTodos.map(t => {
    const col = COLORS[t.type] || COLORS.workflow;
    return `<li>
      <span class="done-pip" style="background:${col.fill}"></span>
      ${t.text.replace('\n', ' ')}
      <span class="done-time">${t.time}</span>
    </li>`;
  }).join('');
}

function updateCount() {
  const visible = balls.filter(b => b.visible).length;
  // updated in draw loop
}

// ─── DOUBLE CLICK REMOVE ───────────────────────────────────────────────────
canvas.addEventListener('dblclick', e => {
  const mx = e.clientX, my = e.clientY;
  for (let i = balls.length - 1; i >= 0; i--) {
    const b = balls[i];
    if (!b.visible) continue;
    const dx = mx - b.body.position.x;
    const dy = my - b.body.position.y;
    if (Math.sqrt(dx*dx + dy*dy) < b.r) {
      Composite.remove(world, b.body);
      balls.splice(i, 1);
      if (selectedIdx === i) selectedIdx = -1;
      else if (selectedIdx > i) selectedIdx--;
      break;
    }
  }
});

// ─── HOVER + SELECT ────────────────────────────────────────────────────────
let hoveredIdx = -1;
let selectedIdx = -1;
const tooltip = document.getElementById('tooltip');

canvas.addEventListener('mousemove', e => {
  const mx = e.clientX, my = e.clientY;
  let found = -1;
  balls.forEach((b, i) => {
    if (!b.visible) return;
    const dx = mx - b.body.position.x;
    const dy = my - b.body.position.y;
    if (Math.sqrt(dx*dx + dy*dy) < b.r) found = i;
  });
  hoveredIdx = found;
  canvas.style.cursor = found >= 0 ? 'pointer' : 'default';
  if (found >= 0) {
    const item = balls[found].data;
    tooltip.textContent = item.text.replace('\n', ' ') + ' — ' + item.type;
    tooltip.style.left = (e.clientX + 14) + 'px';
    tooltip.style.top  = (e.clientY - 10) + 'px';
    tooltip.classList.add('show');
  } else {
    tooltip.classList.remove('show');
  }
});

canvas.addEventListener('click', e => {
  // Don't select on swipe release
  if (swipeState) return;
  const mx = e.clientX, my = e.clientY;
  let found = -1;
  balls.forEach((b, i) => {
    if (!b.visible) return;
    const dx = mx - b.body.position.x;
    const dy = my - b.body.position.y;
    if (Math.sqrt(dx*dx + dy*dy) < b.r) found = i;
  });
  selectedIdx = (found === selectedIdx) ? -1 : found;
});

// ─── SCROLL TO RESIZE ──────────────────────────────────────────────────────
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  if (selectedIdx < 0 || selectedIdx >= balls.length) return;
  const ball = balls[selectedIdx];
  const delta = e.deltaY > 0 ? -4 : 4;
  const newR = Math.max(20, Math.min(120, ball.r + delta));
  if (newR === ball.r) return;
  const pos = ball.body.position;
  const vel = ball.body.velocity;
  Composite.remove(world, ball.body);
  const newBody = Bodies.circle(pos.x, pos.y, newR, {
    restitution: 0.52, friction: 0.015, frictionAir: 0.016, density: 0.003, label: 'ball',
  });
  Body.setVelocity(newBody, vel);
  Composite.add(world, newBody);
  ball.body = newBody;
  ball.r = newR;
  // Re-add to mouse constraint
  mc.body = null;
}, { passive: false });

// ─── CONTAINMENT ───────────────────────────────────────────────────────────
Events.on(engine, 'afterUpdate', () => {
  balls.forEach(b => {
    if (!b.visible) return;
    const pos = b.body.position;
    const cx = W/2, cy = H * 0.42;
    const dx = cx - pos.x, dy = cy - pos.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > Math.min(W, H) * 0.43) {
      Body.applyForce(b.body, pos, { x: dx * 0.000038, y: dy * 0.000038 });
    }
  });
});

// ─── RUNNER ────────────────────────────────────────────────────────────────
Matter.Runner.run(Matter.Runner.create(), engine);

// ─── DRAW ──────────────────────────────────────────────────────────────────
function hexToRgb(hex) {
  return {
    r: parseInt(hex.slice(1,3),16),
    g: parseInt(hex.slice(3,5),16),
    b: parseInt(hex.slice(5,7),16)
  };
}
function darken(hex, a) {
  const c = hexToRgb(hex);
  return `rgb(${Math.max(0,c.r-a)},${Math.max(0,c.g-a)},${Math.max(0,c.b-a)})`;
}
function lighten(hex, a) {
  const c = hexToRgb(hex);
  return `rgb(${Math.min(255,c.r+a)},${Math.min(255,c.g+a)},${Math.min(255,c.b+a)})`;
}

function drawFrame() {
  requestAnimationFrame(drawFrame);

  ctx.fillStyle = '#111118';
  ctx.fillRect(0, 0, W, H);

  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.022)';
  ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  const visibleBalls = balls.filter(b => b.visible);

  visibleBalls.forEach((b, i) => {
    const { x, y } = b.body.position;
    const r = b.r;
    const col = COLORS[b.data.type] || COLORS.workflow;
    const origIdx = balls.indexOf(b);
    const isHovered  = hoveredIdx === origIdx;
    const isSelected = selectedIdx === origIdx;

    // Swipe ghost — show displacement while dragging
    if (swipeState && swipeState.ballIdx === origIdx) {
      const dx = (typeof window._lastMouseX !== 'undefined') ? window._lastMouseX - swipeState.startX : 0;
      if (Math.abs(dx) > 15) {
        ctx.globalAlpha = 0.15;
        ctx.beginPath();
        ctx.arc(swipeState.bodyStartX + dx * 0.3, y, r, 0, Math.PI*2);
        ctx.fillStyle = col.fill;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // Glow
    if (isHovered || isSelected) {
      const glow = ctx.createRadialGradient(x, y, r*0.4, x, y, r*2.1);
      glow.addColorStop(0, col.fill + (isSelected ? '35' : '22'));
      glow.addColorStop(1, col.fill + '00');
      ctx.beginPath(); ctx.arc(x, y, r*2.1, 0, Math.PI*2);
      ctx.fillStyle = glow; ctx.fill();
    }

    // Shadow
    ctx.beginPath(); ctx.arc(x+2, y+3, r, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.32)'; ctx.fill();

    // Body
    const grad = ctx.createRadialGradient(x-r*0.3, y-r*0.35, r*0.05, x, y, r);
    grad.addColorStop(0, lighten(col.fill, isHovered ? 50 : 25));
    grad.addColorStop(0.55, col.fill);
    grad.addColorStop(1, darken(col.fill, 38));
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fillStyle = grad; ctx.fill();

    // Border
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.strokeStyle = isSelected ? 'rgba(255,255,255,0.9)' : isHovered ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.1)';
    ctx.lineWidth = isSelected ? 2.5 : isHovered ? 1.5 : 0.7;
    ctx.stroke();

    // Selection ring
    if (isSelected) {
      ctx.beginPath(); ctx.arc(x, y, r+6, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4,5]); ctx.stroke(); ctx.setLineDash([]);
    }

    // Shine
    const shine = ctx.createRadialGradient(x-r*0.32, y-r*0.38, 0, x-r*0.15, y-r*0.25, r*0.52);
    shine.addColorStop(0, 'rgba(255,255,255,0.26)');
    shine.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fillStyle = shine; ctx.fill();

    // Text
    const lines = b.data.text.split('\n');
    const fs = Math.max(9, r * 0.24);
    ctx.font = `600 ${fs}px Syne, sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const lh = fs * 1.25;
    lines.forEach((line, li) => {
      ctx.fillText(line, x, y + (li - (lines.length-1)/2) * lh);
    });

    // Type dot
    ctx.beginPath(); ctx.arc(x + r*0.62, y - r*0.62, 4.5, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.45)'; ctx.fill();
  });

  // Counter
  ctx.font = '400 11px Syne Mono, monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.13)';
  ctx.textAlign = 'left'; ctx.textBaseline = 'top';
  const shown = visibleBalls.length;
  const total = balls.length;
  ctx.fillText(activeFilter === 'all' ? `${total} offen` : `${shown} / ${total} offen`, 36, 80);
}

// Track mouse globally for swipe ghost
window.addEventListener('mousemove', e => { window._lastMouseX = e.clientX; });

drawFrame();

// Spawn initial
INITIAL_TODOS.forEach((t, i) => setTimeout(() => spawnBall({ ...t, id: i+1 }), i * 100));

window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight - 80;
  canvas.width = W; canvas.height = H;
  // Rebuild walls
  walls.forEach(w => Composite.remove(world, w));
  walls = buildWalls();
  Composite.add(world, walls);
});
</script>
</body>
</html>
